defmodule Cmplx do

  def new(r,i) do
    #return the complex number with the real value r and imaginary i
    {:cmplx, r, i}
  end

  def add(a,b) do
    #adds two complex numbers
    {:cmplx, xa, ya} = a
    {:cmplx, xb, yb} = b
    {:cmplx, xa+xb, ya+yb}
  end

  def sqr(a) do
    #squares the complex number
    {:cmplx, x, y} = a
    {:cmplx, x*x - y*y, 2*x*y}
  end

  def abs(a) do
    #the absolute value of the complex number
    {:cmplx, x, y} = a
    :math.sqrt(x*x + y*y)
  end

end

defmodule Brot do

  def mandelbrot(c, m) do
    z0 = Cmplx.new(0, 0)
    i = 0
    test(i, z0, c, m)
  end

  def test(i, _z, _c, m) when i > m do 0 end
  def test(i, z, c, m) do
  if Cmplx.abs(z) > 2 do
      i
    else
      test(i+1, Cmplx.add(Cmplx.sqr(z), c), c, m)
    end
  end

end

defmodule PPM do

  # write(name, image) The image is a list of rows, each row a list of
  # tuples {R,G,B}. The RGB values are 0-255.

  def write(name, image) do
    height = length(image)
    width = length(List.first(image))
    {:ok, fd} = File.open(name, [:write])
    IO.puts(fd, "P6")
    IO.puts(fd, "#generated by ppm.ex")
    IO.puts(fd, "#{width} #{height}")
    IO.puts(fd, "255")
    rows(image, fd)
    File.close(fd)
  end

  defp rows(rows, fd) do
    Enum.each(rows, fn(r) ->
      colors = row(r)
      IO.write(fd, colors)
    end)
  end

  defp row(row) do
    List.foldr(row, [], fn({:rgb, r, g, b}, a) ->
      [r, g, b | a]
    end)
  end

end

defmodule Color do

  def convert(depth, max) do
    a = depth/max * 4
    x = trunc(a)
    y = trunc(255*(a-x))

    case trunc(a) do
      0-> {:rgb, y,0,0}
      1-> {:rgb, 255,y,0}
      2-> {:rgb, 255-y,255,0}
      3-> {:rgb, 0, 255, y}
      4-> {:rgb, 0, 255-y, 255}
    end
  end

end


defmodule Mandel do
  def mandelbrot(width, height, x, y, k, max) do
    trans = fn(w, h) ->
      Cmplx.new(x + k * (w - 1), y - k * (h - 1))
    end
    rows(width, height, trans, max, [])
  end

  def rows(_w, 0, _t, _max, acc) do
    #IO.puts("END ROWS")
    Enum.reverse(acc)
  end
  def rows(w, h, t, max, acc) do
    #IO.puts("rows | w:#{w}|h#{h}");
    rows(w, h-1, t, max, [ row(w, h, t, max, []) | acc])
  end

  def row(0,_,_,_, acc) do
    #IO.puts("END LINE");
    Enum.reverse(acc)
  end
  def row(w, h, t, max, acc) do
    #IO.puts("Line | w:#{w}|h#{h}");
    c = t.(w,h)
    depth = Brot.mandelbrot(c, max);
    rgb = Color.convert(depth, max);
    #IO.puts(inspect(depth))
    #IO.puts(inspect(rgb))
    row(w-1, h, t, max, [rgb | acc])
  end
end

defmodule Main do
  def demo() do
    small(-1.25, -0.2, -0.9)
    #small(-2.6, 1.2, 1.2)

  end



    def small(x0, y0, xn) do
    width = 2556
    height = 1440
    depth = 64*4
    k = (xn - x0) / width
    image = Mandel_v2.mandelbrot(width, height, x0, y0, k, depth)
    PPM.write("small.ppm", image)
  end
end

defmodule Mandel_v2 do
  def mandelbrot(width, height, x, y, k, max) do
    trans = fn(w, h) ->
      Cmplx.new(x + k * (w - 1), y - k * (h - 1))
    end
    rows(width, height, trans, max, [])
  end

  def rows(_w, 0, _t, _max, acc) do
    Enum.reverse(acc)
  end
  def rows(w, h, t, max, acc) when h >=12 do
    f1 = Async.eval(fn -> row(w, h, t, max, []) end)
    f2 = Async.eval(fn -> row(w, h-1, t, max, [])end)
    f3 = Async.eval(fn -> row(w, h-2, t, max, [])end)
    f4 = Async.eval(fn -> row(w, h-3, t, max, [])end)
    f5 = Async.eval(fn -> row(w, h-4, t, max, [])end)
    f6 = Async.eval(fn -> row(w, h-5, t, max, [])end)
    f7 = Async.eval(fn -> row(w, h-6, t, max, []) end)
    f8 = Async.eval(fn -> row(w, h-7, t, max, [])end)
    f9 = Async.eval(fn -> row(w, h-8, t, max, [])end)
    f10 = Async.eval(fn -> row(w, h-9, t, max, [])end)
    f11 = Async.eval(fn -> row(w, h-10, t, max, [])end)
    f12 = Async.eval(fn -> row(w, h-11, t, max, [])end)
    f=[f1|[f2|[f3|[f4|[f5|[f6|[f7|[f8|[f9|[f10|[f11|[f12]]]]]]]]]]]]
    result = collect_results(f, acc)
    rows(w, h-12, t, max, result)
  end
  def rows(w, h, t, max, acc) when h >= 6 do
    f1 = Async.eval(fn -> row(w, h, t, max, []) end)
    f2 = Async.eval(fn -> row(w, h-1, t, max, [])end)
    f3 = Async.eval(fn -> row(w, h-2, t, max, [])end)
    f4 = Async.eval(fn -> row(w, h-3, t, max, [])end)
    f5 = Async.eval(fn -> row(w, h-4, t, max, [])end)
    f6 = Async.eval(fn -> row(w, h-5, t, max, [])end)
    f=[f1|[f2|[f3|[f4|[f5|[f6]]]]]]
    result = collect_results(f, acc)
    #IO.puts(length(result))
    rows(w, h-6, t, max, result)
    #rows(w, h-6, t, max, [Async.collect(f6)|[Async.collect(f5)|[Async.collect(f4)|[Async.collect(f3)|[Async.collect(f2)|[Async.collect(f1)| acc]]]]]])
  end
  def rows(w, h, t, max, acc) do
    rows(w, h-1, t, max, [ row(w, h, t, max, []) | acc])
  end

  def collect_results([], acc) do acc end
  def collect_results([ref|rest], acc) do
    collect_results(rest, [Async.collect(ref)| acc])
  end

  def row(0,_,_,_, acc) do
    Enum.reverse(acc)
  end
  def row(w, h, t, max, acc) do
    c = t.(w,h)
    depth = Brot.mandelbrot(c, max);
    rgb = Color.convert(depth, max);
    row(w-1, h, t, max, [rgb | acc])
  end
end
defmodule Async do

  def eval(f) do
    me = self()
    ref = make_ref()
    spawn_link(fn -> send(me,{:async, ref, f.()})end)
    ref
  end

  def collect(ref) do
    receive do
      {:async, ^ref, res} -> res
    end
  end

end
